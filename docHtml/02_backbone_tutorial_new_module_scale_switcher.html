
                        <!DOCTYPE html>
                        <html>
                            <head>
                                <meta charset="utf-8">
                                <title>üìöMasterportal Docs</title>
                                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
                            </head>
                            <body>
                            <h2>Tutorial: Ein neues Tool erstellen (Scale-Switcher)</h2>
<p>Eine Schritt f√ºr Schritt Dokumentation zur Erstellung eines neuen Tools (Moduls).</p>
<h3>Beispiel Anforderung</h3>
<p>Wir wollen ein Tool schreiben, √ºber welches man den Kartenma√üstab steuern kann. Dabei soll √ºber ein Drop-Down-Men√º der Ma√üstab ausgew√§hlt werden. Sobald der Ma√üstab gesetzt wurde, soll sich die Karte anpassen.
Dar√ºber hinaus soll unser Tool auf √Ñnderungen des Kartenma√üstabes reagieren und den entsprechend aktuellen Ma√üstab im Drop-Down-Menu anzeigen.</p>
<h3>Neues Tool anlegen</h3>
<p>In das Verzeichnis ‚Äúmodules -&gt; tools‚Äù wechseln und einen neuen Ordner erstellen. Aus dem Ordnernamen sollte ersichtlich sein, um was f√ºr ein Tool es sich dabei handelt - z.B. ‚Äúscale‚Äù. Die f√ºr dieses Tool ben√∂tigten Dateien anlegen. In der View (view.js) wird auf Interaktion mit dem Nutzer reagiert und das Tool neu gerendert. Dazu wird das Template (template.html) ben√∂tigt, welches den Bauplan des Tools enth√§lt. Im Model (model.js) werden die Daten und deren Logik vorgehalten. Stylingparameter werden in der style.scss konfiguriert.</p>
<pre><code>-  modules
   | -&gt; tools
   |    |-&gt; scale
   |    |    | -&gt; view.js
   |    |    | -&gt; model.js
   |    |    | -&gt; template.html
   |    |    | -&gt; style.css
</code></pre>
<h3>Scale View erstellen und zur√ºckgeben</h3>
<p>Datei <em>modules/tools/scale/view.js</em> √∂ffnen und die View mit folgendem Standardschema erzeugen.</p>
<pre><code class="language-js">
const ScaleView = Backbone.View.extend({
      // wird aufgerufen wenn die View erstellt wird
      initialize: function () {
      }
    });

export default ScaleView;

</code></pre>
<h3>Scale View initialisieren</h3>
<p>In die datei <em>js/app.js</em> wechseln, Scale View importieren und initialiseren. Darauf achten, dass das Tool grunds√§tzlich erst nach dem Core initialsiert werden. (Dies gilt f√ºr jedes Modul) Das Initialsieren eines Tools erfolgt als switch-case Anweiszung innerhalb einer vorgesehene _.each Schleife Zurzeit ab Zeile 157.</p>
<pre><code class="language-js">
// View importieren
import ScaleView from &quot;../modules/tools/scale/view&quot;;
// View initialsieren
 _.each(Radio.request(&quot;ModelList&quot;, &quot;getModelsByAttributes&quot;, {type: &quot;tool&quot;}), function (tool) {
      switch (tool.id) {
          case &quot;scale&quot;: {
            new ScaleView({model: tool});
            break;
          }
          ... // weitere Tools
      }
  });


</code></pre>
<h3>Template erstellen</h3>
<p>Datei <em>modules/tools/scale/template.html</em> √∂ffnen, Template coden und mit Bootstrap Klassen versehen</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;select class=&quot;form-control input-sm&quot;&gt;
  &lt;option&gt;1&lt;/option&gt;
  &lt;option&gt;2&lt;/option&gt;
  &lt;option&gt;3&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h3>Template in die View einbinden</h3>
<p>Das Template muss in die View eingebunden werden. Hierzu wird in einer neuen Variable (ScaleTemplate) das Template importiert und mithilfe von underscore (&quot;_&quot;) als Template zur Verf√ºgung gestellt. Dieses Template wird dem View als Attribut ‚Äútemplate‚Äù zugef√ºgt.</p>
<pre><code class="language-js">
   import ScaleTemplate from &quot;text-loader!./template.html&quot;;


const ScaleView = Backbone.View.extend({
    initialize: function () {
    },
    // underscore template Funktion
    template: _.template(ScaleTemplate)
});

export default ScaleView;

</code></pre>
<h3>Template initial rendern</h3>
<p>Beim Laden der View, soll sich sofort das Tool in rendern wenn der Parameter ‚ÄúisActive‚Äù auf true gesetzt ist. Dazu wird in der initialize()-Funktion eine if-Abfrage definiert, welche die render-Funktion aufruft. Beim sp√§teren aktivieren soll sich das Tool ebenfalls zeichnen. Dies wird √ºber einen Listener realisert, der auf Ver√§ndeurngen des Paramters ‚ÄúisActive‚Äù wartet und anschlie√üend die render-Funktion <a href="http://aufruft.In">aufruft.In</a> der render-Funktion passiert folgendes, wenn das Tool aktiv ist:
Die View wird and das HTML win-body gezeichnet.
Der View wird das Template zugef√ºgt.</p>
<pre><code class="language-js">

const ScaleView = Backbone.View.extend({
    initialize: function () {
        this.listenTo(this.model, {
            &quot;change:isActive&quot;: this.render
        });
        if (this.model.get(&quot;isActive&quot;) === true) {
            this.render(this.model, true);
        }
    },
    template: _.template(ScaleTemplate),

    // Konvention: Die Methode f√ºrs zeichnen der View, hei√üt render.
    render: function (model, value) {
        if (value) {
            this.setElement(document.getElementsByClassName(&quot;win-body&quot;)[0]);
            this.$el.html(this.template());
        }

        return this;
    }
});

export default ScaleView;

</code></pre>
<p>Jede View bekommt automatisch ein top level DOM Element (this.el) zugewiesen.
Standardeinstellung f√ºr das DOM Element ist ein <em>div</em> Tag. In diesem Fall zeichnet sich beim rendern ein <em>div</em> an den Body. Dieser <em>div</em> ist bef√ºllt mit dem Inhalt des <em>templates</em>.</p>
<h3>scss Regeln definieren</h3>
<p>Datei <em>modules/tools/scale/style.scss</em> √∂ffnen und folgenden Code eingeben.</p>
<pre><code class="language-css">.scale-switcher {
    border: 2px solid red;
}

Damit es keine Probleme mit scss Regeln anderer Module/Tools gibt, wird √ºber eine definierte Klasse &quot;scale-switcher&quot; gestylt.
</code></pre>
<h3>Model erstellen und zur√ºckgeben</h3>
<p>Datei <em>modules/tools/scale/model.js</em> √∂ffnen und Model definieren. Das Model erbt vom der Elternklasse <em>Tool</em> das im Core <em>moduels/core/modelList/tool/model.js</em> definiert ist. √úber den Aufruf der Funktion <em>superInitialize</em> wird der Listener, der die Aktivierung der Tools regelt, von der Elternklasse √ºbernommen. Dem Parameter defaults werden alle Attribute mit einem Default-Wert eingetragen, die in diesem Model konfiguriert werden k√∂nnen (z.B. ein Glyphicon). Dort wird auch das Attribute ‚ÄúrenderToWindow‚Äù auf true gestezt, damit sich der Scale-Switcher im vererbten Fenster zeichnet.</p>
<pre><code class="language-js">
import Tool from &quot;../../core/modelList/tool/model&quot;;

const ScaleModel = Tool.extend({
    defaults: _.extend({}, Tool.prototype.defaults, {
        glyphicon: &quot;glyphicon-resize-full&quot;,
        renderToWindow: true
    }),
    // wird aufgerufen wenn das Model erstellt wird
    initialize: function () {
        this.superInitialize();
    }
});

export default ScaleModel;

</code></pre>
<h3>Model der View zuweisen</h3>
<p>In der ModelList <em>modules/core/modelList/list.js</em> wird das Model import und unter dem Eintrag <em>model</em> in dem vorgesehenen if-else Statement per new ScaleModel() instanziiert.</p>
<pre><code class="language-js">
import ScaleModel from &quot;../../tools/scale/model&quot;;

 else if (attrs.type === &quot;tool&quot;) {
    else if (attrs.id === &quot;scale&quot;) {
        return new ScaleModel(attrs, options);
    }
    ... // weitere Tool-Models
 }

</code></pre>
<h3>Setter Methoden f√ºr das Model schreiben</h3>
<p>Mithilfe von Setter-Methoden werden Member-Variablen im Model definiert bzw √ºberschrieben.
Dazu werden Default-Werte eingetragen.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    defaults: _.extend({}, Tool.prototype.defaults, {
        glyphicon: &quot;glyphicon-resize-full&quot;,
        renderToWindow: true,
        scales: &quot;&quot;,
        currentScale: &quot;&quot;
    },
    initialize: function () {
        this.superInitialize();
    },

    // Setter f√ºr alle verf√ºgbaren Ma√üst√§be
    setScales: function (value) {
        this.set(&quot;scales&quot;, value);
    },
    // Setter f√ºr den aktuellen Ma√üstab
    setCurrentScale: function (value) {
        this.set(&quot;currentScale&quot;, value);
    }
});

export default ScaleModel;

</code></pre>
<h3>Ma√üst√§be der Karte abfragen und setzen</h3>
<p>Die Kommunikation mit anderen Modulen/Tools erfolgt √ºber Backbone.Radio. In diesem Fall mit dem <em>MapView</em> Modul (<em>modules/core/mapView.js</em>), in dem alle Scales definiert sind. Das <em>MapView</em> Modul stellt bereits √ºber Backbone.Radio die Funktion <em>getScales</em> zur Verf√ºgung, √ºber die alle Scales abgefragt werden k√∂nnen.
Diese Ma√üst√§be werden mittels <em>Radio</em> requested und im ScaleModel √ºber die entsprechende Setter-Funktion gesetzt. Um sicher zu gehen, dass die <em>Map</em> bereits geladen ist wird ein Listener definiert, der auf eine entsprechende Nachricht wartet, bevor getScales getriggert wird.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    initialize: function () {
        this.superInitialize();
        this.listenTo(Radio.channel(&quot;Map&quot;), {
            &quot;isReady&quot;: function () {
                // initial alle Scales der Karte abfragen
                this.setScales(Radio.request(&quot;MapView&quot;, &quot;getScales&quot;));
            }
        });
    },
    ...
});

export default ScaleModel;

</code></pre>
<h3>Aktuellen Kartenma√üstab abfragen und setzen</h3>
<p>Analog zu ‚ÄúgetScales‚Äù k√∂nnen von der MapView auch der aktuelle Ma√üstab abgefragt werden. Hierzu werden die aktuellen Optionen requested und von diesem Objekt das Attribut ‚Äúscale‚Äù verwendet. Dieses wird √ºber den entsprechenden Setter als Model-Variable gesetzt.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    initialize: function () {
        this.superInitialize();
        this.listenTo(Radio.channel(&quot;Map&quot;), {
            &quot;isReady&quot;: function () {
                ...
                this.setCurrentScale(Radio.request(&quot;MapView&quot;, &quot;getOptions&quot;).scale);
            }
        });
    },
    ...
});

export default ScaleModel;
</code></pre>
<h3>Model Attribute ans Template √ºbergeben</h3>
<p>Da sich das Template dynamisch aus den Daten des Models erzeugen soll, muss die render()-Funktion erweitert werden. Indem das Model an das Template √ºbergeben wird, k√∂nnen die Model-Variablen im Template verwendet werden.</p>
<pre><code class="language-js">
const ScaleView = Backbone.View.extend({
    initialize: function () {
        ...
    },
    template: _.template(ScaleTemplate),
    render: function (model, value) {
        // alle Model Attribute (currentScale, scales)
        var attr = model.toJSON();

        if (value) {
            this.setElement(document.getElementsByClassName(&quot;win-body&quot;)[0]);
            this.$el.html(this.template(attr));
        }

        return this;
    }
});

export default ScaleView;

</code></pre>
<h3>Ma√üst√§be in der View anzeigen bzw. ins Template scripten</h3>
<p>Im Tag ‚Äúselect‚Äù wird die Klasse ‚Äúscale-switcher‚Äù definiert.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;select class=&quot;form-control input-sm scale-switcher&quot;&gt;
  &lt;% _.each(scales, function (scale) { %&gt;
    &lt;% if (scale === currentScale) { %&gt;
        &lt;option selected&gt;&lt;%= scale %&gt;&lt;/option&gt;
    &lt;% }
    else { %&gt;
        &lt;option&gt;&lt;%= scale %&gt;&lt;/option&gt;
    &lt;% } %&gt;
  &lt;% }); %&gt;
&lt;/select&gt;
</code></pre>
<h3>User Input in der View registrieren</h3>
<p>In der View haben wir die M√∂glichkeit auf events im HTML zu h√∂ren. In diesem Fall wollen wir darauf h√∂ren, wenn sich im Drop-Down-Men√º ein Eintrag ge√§ndert hat. Wenn dieses Event eintrifft, √ºberschreiben wir im Model das Attribut ‚ÄúcurrentScale‚Äù mit dem Wert aus dem Drop-Down-Men√º. Daf√ºr verwenden wir die Setter-Methode ‚ÄúsetCurrentScale‚Äù des Models.</p>
<pre><code class="language-js">
const ScaleView = Backbone.View.extend({
    ...,
    events: {
        // DOM Change Event f√ºhrt this.setCurrentScale aus
        &quot;change .form-control&quot;: &quot;setCurrentScale&quot;
    },
    initialize: function () {...},
    template: _.template(ScaleTemplate),
    render: function () {...},
    // Ruft im Model die Methode setCurrentScale auf
    setCurrentScale: function (evt) {
        this.model.setCurrentScale(parseInt(evt.target.value, 10));
    }
});

export default ScaleView;
</code></pre>
<h3>Model Listener auf change:currentScale</h3>
<p>Durch einen Listener wird bei Ver√§nderung der currentScale der neue Ma√üstab an die Mapview gesendet. Das Attribut ‚ÄúcurrentScale‚Äù wird √ºber die Getter-Funktion von Backbone geholt.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    initialize: function () {
        ...
        this.listenTo(this, {
            &quot;change:currentScale&quot;: function () {
                // Sendet den neuen Ma√üstab an die MapView
                // Dadurch zoomt die Karte in diesen Ma√üstab
                Radio.trigger(&quot;MapView&quot;, &quot;setScale&quot;, this.get(&quot;currentScale&quot;));
            }
        });
        ...
    },
    setScales: function (value) {...},
    setCurrentScale: function (value) {...}
});

export default ScaleModel;
</code></pre>
<h3>Model Listener auf MapView changedOptions</h3>
<p>Wir wollen nicht nur den Ma√üstab der Karte setzen k√∂nnen , sondern auch auf Ver√§nderungen des Ma√üstabs reagieren. √Ñndert sich der Kartenma√üstab, soll sich in unserem Tool der aktuelle Ma√üstab anpassen.
Dazu wird in der Initialize-Funktion ein Listener geschrieben. Dieser H√∂rt per Radio auf ein ‚ÄúchangedOptions‚Äù-Event des Radio-Channels ‚ÄúMapView‚Äù. Sobald ein solches Event getriggert wird, wird mithilfe unserer Setter-Methode <em>setCurrentScale()</em> der aktuelle Ma√üstab im Model √ºberschrieben.</p>
<pre><code class="language-js">
const ScaleModel = Tool.extend({
    initialize: function () {
        ...
        this.listenTo(Radio.channel(&quot;MapView&quot;), {
            // Wird ausgel√∂st wenn sich Zoomlevel, Center
            // oder Resolution der Karte √§ndert
            &quot;changedOptions&quot;: function (value) {
                this.setCurrentScale(value.scale);
            }
        });
        ...
    },
    ...
});

export default ScaleModel;
</code></pre>
<h3>View Listener auf change currentScale im Model</h3>
<p>Bisher erkennt nur das Model eine Ver√§nderung des aktuellen Kartenma√üstabes. Die View muss jedoch auch darauf h√∂ren, wenn sich in seinem Model der aktuelle Ma√üstab ver√§ndert. Denn dann muss sich das Tool neu zeichnen, sodass der aktuelle Ma√üstab angezeigt wird.</p>
<pre><code class="language-js">const ScaleView = Backbone.View.extend({
    ...
    events: {...}
    initialize: function () {
        this.listenTo(this.model, {
            // Ver√§ndert sich der Ma√üstab der Karte und damit der currentScale
            // des Models, wird die View neu gezeichnet.
            &quot;change:currentScale&quot;: this.render
        });
        ...
    },
    render: function () {...},
    setCurrentScale: function (evt) {...}
});

export default ScaleView;

</code></pre>
<h3>Tool in der config.json konfigurieren</h3>
<p>Um das Tool in einem Portal zu verwenden, muss dies in der config.json konfiguriert werden</p>
<pre><code class="language-js">      &quot;tools&quot;:
      {
        &quot;name&quot;: &quot;Werkzeuge&quot;,
        &quot;glyphicon&quot;: &quot;glyphicon-wrench&quot;,
        &quot;children&quot;: {
          &quot;scale&quot;:
          {
            &quot;name&quot;: &quot;Scale Switcher&quot;,
            &quot;glyphicon&quot;: &quot;glyphicon-resize-full&quot;
          },
          ... // weitere Tools
        }
      }
</code></pre>

                            </body>
                        </html>